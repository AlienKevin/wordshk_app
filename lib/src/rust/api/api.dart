// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.11.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';

Stream<String> createLogStream({dynamic hint}) =>
    RustLib.instance.api.createLogStream(hint: hint);

Future<void> initApi({dynamic hint}) =>
    RustLib.instance.api.initApi(hint: hint);

Future<List<EntrySummary>> getEntrySummaries(
        {required Uint32List entryIds, dynamic hint}) =>
    RustLib.instance.api.getEntrySummaries(entryIds: entryIds, hint: hint);

Future<void> generatePrIndices(
        {required Romanization romanization, dynamic hint}) =>
    RustLib.instance.api
        .generatePrIndices(romanization: romanization, hint: hint);

Future<CombinedSearchResults> combinedSearch(
        {required int capacity,
        required String query,
        required Script script,
        required Romanization romanization,
        dynamic hint}) =>
    RustLib.instance.api.combinedSearch(
        capacity: capacity,
        query: query,
        script: script,
        romanization: romanization,
        hint: hint);

Future<List<EgSearchResult>> egSearch(
        {required int capacity,
        required int maxFirstIndexInEg,
        required String query,
        required Script script,
        dynamic hint}) =>
    RustLib.instance.api.egSearch(
        capacity: capacity,
        maxFirstIndexInEg: maxFirstIndexInEg,
        query: query,
        script: script,
        hint: hint);

Future<String> getEntryJson({required int id, dynamic hint}) =>
    RustLib.instance.api.getEntryJson(id: id, hint: hint);

Future<List<String>> getEntryGroupJson({required int id, dynamic hint}) =>
    RustLib.instance.api.getEntryGroupJson(id: id, hint: hint);

Future<int?> getEntryId(
        {required String query, required Script script, dynamic hint}) =>
    RustLib.instance.api.getEntryId(query: query, script: script, hint: hint);

Future<List<String>> getJyutping({required String query, dynamic hint}) =>
    RustLib.instance.api.getJyutping(query: query, hint: hint);

class CombinedSearchResults {
  final (int?, List<VariantSearchResult>) variantResults;
  final (int?, List<PrSearchResult>) prResults;
  final (int?, List<EnglishSearchResult>) englishResults;

  const CombinedSearchResults({
    required this.variantResults,
    required this.prResults,
    required this.englishResults,
  });

  @override
  int get hashCode =>
      variantResults.hashCode ^ prResults.hashCode ^ englishResults.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CombinedSearchResults &&
          runtimeType == other.runtimeType &&
          variantResults == other.variantResults &&
          prResults == other.prResults &&
          englishResults == other.englishResults;
}

class EgSearchResult {
  final int id;
  final int defIndex;
  final int egIndex;
  final MatchedInfix matchedEg;

  const EgSearchResult({
    required this.id,
    required this.defIndex,
    required this.egIndex,
    required this.matchedEg,
  });

  @override
  int get hashCode =>
      id.hashCode ^ defIndex.hashCode ^ egIndex.hashCode ^ matchedEg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EgSearchResult &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          defIndex == other.defIndex &&
          egIndex == other.egIndex &&
          matchedEg == other.matchedEg;
}

class EnglishSearchResult {
  final int id;
  final int defIndex;
  final List<String> variants;
  final List<MatchedSegment> matchedEng;

  const EnglishSearchResult({
    required this.id,
    required this.defIndex,
    required this.variants,
    required this.matchedEng,
  });

  @override
  int get hashCode =>
      id.hashCode ^ defIndex.hashCode ^ variants.hashCode ^ matchedEng.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EnglishSearchResult &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          defIndex == other.defIndex &&
          variants == other.variants &&
          matchedEng == other.matchedEng;
}

class EntryDef {
  final String yueTrad;
  final String yueSimp;
  final String eng;

  const EntryDef({
    required this.yueTrad,
    required this.yueSimp,
    required this.eng,
  });

  @override
  int get hashCode => yueTrad.hashCode ^ yueSimp.hashCode ^ eng.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryDef &&
          runtimeType == other.runtimeType &&
          yueTrad == other.yueTrad &&
          yueSimp == other.yueSimp &&
          eng == other.eng;
}

class EntrySummary {
  final String variantTrad;
  final String variantSimp;
  final List<EntryDef> defs;

  const EntrySummary({
    required this.variantTrad,
    required this.variantSimp,
    required this.defs,
  });

  @override
  int get hashCode =>
      variantTrad.hashCode ^ variantSimp.hashCode ^ defs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntrySummary &&
          runtimeType == other.runtimeType &&
          variantTrad == other.variantTrad &&
          variantSimp == other.variantSimp &&
          defs == other.defs;
}

class MatchedInfix {
  final String prefix;
  final String query;
  final String suffix;

  const MatchedInfix({
    required this.prefix,
    required this.query,
    required this.suffix,
  });

  @override
  int get hashCode => prefix.hashCode ^ query.hashCode ^ suffix.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatchedInfix &&
          runtimeType == other.runtimeType &&
          prefix == other.prefix &&
          query == other.query &&
          suffix == other.suffix;
}

class MatchedSegment {
  final String segment;
  final bool matched;

  const MatchedSegment({
    required this.segment,
    required this.matched,
  });

  @override
  int get hashCode => segment.hashCode ^ matched.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatchedSegment &&
          runtimeType == other.runtimeType &&
          segment == other.segment &&
          matched == other.matched;
}

class PrSearchResult {
  final int id;
  final List<String> variants;
  final List<MatchedSegment> matchedPr;
  final List<String> yues;
  final List<String> engs;

  const PrSearchResult({
    required this.id,
    required this.variants,
    required this.matchedPr,
    required this.yues,
    required this.engs,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      variants.hashCode ^
      matchedPr.hashCode ^
      yues.hashCode ^
      engs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrSearchResult &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          variants == other.variants &&
          matchedPr == other.matchedPr &&
          yues == other.yues &&
          engs == other.engs;
}

enum Romanization {
  jyutping,
  yale,
}

enum Script {
  simplified,
  traditional,
}

class VariantSearchResult {
  final int id;
  final MatchedInfix matchedVariant;
  final List<String> yues;
  final List<String> engs;

  const VariantSearchResult({
    required this.id,
    required this.matchedVariant,
    required this.yues,
    required this.engs,
  });

  @override
  int get hashCode =>
      id.hashCode ^ matchedVariant.hashCode ^ yues.hashCode ^ engs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VariantSearchResult &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          matchedVariant == other.matchedVariant &&
          yues == other.yues &&
          engs == other.engs;
}
